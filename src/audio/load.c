#include <ultra64.h>
#include <macros.h>
#include "load.h"
#include "data.h"
#include "heap.h"
#include "internal.h"

#define ALIGN16(val) (((val) + 0xF) & ~0xF)
struct SharedDma {
    /*0x0*/ u8 *buffer;       // target, points to pre-allocated buffer
    /*0x4*/ uintptr_t source; // device address
    /*0x8*/ u16 sizeUnused;   // set to bufSize, never read
    /*0xA*/ u16 bufSize;      // size of buffer
    /*0xC*/ u8 unused2;       // set to 0, never read
    /*0xD*/ u8 reuseIndex;    // position in sSampleDmaReuseQueue1/2, if ttl == 0
    /*0xE*/ u8 ttl;           // duration after which the DMA can be discarded
};                            // size = 0x10

extern OSMesgQueue D_803B6720;
extern OSIoMesg D_803B6740;

extern OSMesgQueue gCurrAudioFrameDmaQueue; // gCurrAudioFrameDmaQueue
extern OSMesg gCurrAudioFrameDmaMesgBufs[AUDIO_FRAME_DMA_QUEUE_SIZE]; // gCurrAudioFrameDmaMesgBufs
extern OSIoMesg gCurrAudioFrameDmaIoMesgBufs[AUDIO_FRAME_DMA_QUEUE_SIZE]; // gCurrAudioFrameDmaIoMesgBufs

extern struct SharedDma sSampleDmas[0x60]; // sSampleDmas
extern u32 gSampleDmaNumListItems; // gSampleDmaNumListItems
extern u32 sSampleDmaListSize1; // sSampleDmaListSize1
extern s32 D_803B6E60; // sUnused80226B40

extern u8 sSampleDmaReuseQueue1[256]; // sSampleDmaReuseQueue1
extern u8 sSampleDmaReuseQueue2[256]; // sSampleDmaReuseQueue2
extern u8 sSampleDmaReuseQueueTail1; // sSampleDmaReuseQueueTail1
extern u8 sSampleDmaReuseQueueTail2; // sSampleDmaReuseQueueTail2
extern u8 sSampleDmaReuseQueueHead1; // sSampleDmaReuseQueueHead1
extern u8 sSampleDmaReuseQueueHead2; // sSampleDmaReuseQueueHead2



extern void *soundAlloc(struct SoundAllocPool *pool, u32 size);

/**
 * Performs an immediate DMA copy
 */
// audio_dma_copy_immediate
void audio_dma_copy_immediate(uintptr_t devAddr, void *vAddr, size_t nbytes) {
    stubbed_printf_3("Romcopy %x -> %x ,size %x\n", devAddr, vAddr, nbytes);
    osInvalDCache(vAddr, nbytes);
    osPiStartDma(&D_803B6740, OS_MESG_PRI_HIGH, OS_READ, devAddr, vAddr, nbytes, &D_803B6720);
    osRecvMesg(&D_803B6720, NULL, OS_MESG_BLOCK);
    stubbed_printf_0("Romcopyend\n");
}

const char audioString34[] = "CAUTION:WAVE CACHE FULL %d";
const char audioString35[] = "LOAD  Rom :%x -> Ram :%x  Len:%x\n";
const char audioString36[] = "BASE %x %x\n";
const char audioString37[] = "LOAD %x %x %x\n";
const char audioString38[] = "INSTTOP    %x\n";
const char audioString39[] = "INSTMAP[0] %x\n";
const char audioString40[] = "already flags %d\n";
const char audioString41[] = "already flags %d\n";
const char audioString42[] = "ERR:SLOW BANK DMA BUSY\n";
const char audioString43[] = "ERR:SLOW DMA BUSY\n";
const char audioString44[] = "Check %d  bank %d\n";
const char audioString45[] = "Cache Check\n";
const char audioString46[] = "NO BANK ERROR\n";
const char audioString47[] = "BANK %d LOADING START\n";
const char audioString48[] = "BANK %d LOAD MISS (NO MEMORY)!\n";
const char audioString49[] = "BANK %d ALREADY CACHED\n";
const char audioString50[] = "BANK LOAD MISS! FOR %d\n";


const char audioString51[] = "Seq %d Loading Start\n";

const char audioString52[] = "Heap Overflow Error\n";

const char asdf[] = "SEQ  %d ALREADY CACHED\n";
const char fdsa[] = "Ok,one bank slow load Start \n";
const char af[] = "Sorry,too many %d bank is none.fast load Start \n";



/**
 * Performs an asynchronus (normal priority) DMA copy
 */
//audio_dma_copy_async
void func_800BAAF8(uintptr_t devAddr, void *vAddr, size_t nbytes, OSMesgQueue *queue, OSIoMesg *mesg) {
    osInvalDCache(vAddr, nbytes);
    osPiStartDma(mesg, OS_MESG_PRI_NORMAL, OS_READ, devAddr, vAddr, nbytes, queue);
}
//#else
//GLOBAL_ASM("asm/non_matchings/audio/load/func_800BAAF8.s")
//#endif

//#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
//? osPiStartDma(s32, ?, ?, s32, void *, u32, s32); // extern


/**
 * Performs a partial asynchronous (normal priority) DMA copy. This is limited
 * to 0x1000 bytes transfer at once.
 */
// audio_dma_partial_copy_async
void func_800BAB58(uintptr_t *devAddr, u8 **vAddr, ssize_t *remaining, OSMesgQueue *queue, OSIoMesg *mesg) {
    ssize_t transfer = (*remaining >= 0x1000 ? 0x1000 : *remaining);
    *remaining -= transfer;
    osInvalDCache(*vAddr, transfer);
    osPiStartDma(mesg, OS_MESG_PRI_NORMAL, OS_READ, *devAddr, *vAddr, transfer, queue);
    *devAddr += transfer;
    *vAddr += transfer;
}
//#else
//GLOBAL_ASM("asm/non_matchings/audio/load/func_800BAB58.s")
//#endif

// decrease_sample_dma_ttls

void func_800BAC04() {
    u32 i;

    for (i = 0; i < sSampleDmaListSize1; i++) {
        struct SharedDma *temp = &sSampleDmas[i];
        if (temp->ttl != 0) {
            temp->ttl--;
            if (temp->ttl == 0) {
                temp->reuseIndex = sSampleDmaReuseQueueHead1;
                sSampleDmaReuseQueue1[sSampleDmaReuseQueueHead1++] = (u8) i;
            }
        }
    }

    for (i = sSampleDmaListSize1; i < gSampleDmaNumListItems; i++) {
        struct SharedDma *temp = &sSampleDmas[i];
        if (temp->ttl != 0) {
            temp->ttl--;
            if (temp->ttl == 0) {
                temp->reuseIndex = sSampleDmaReuseQueueHead2;
                sSampleDmaReuseQueue2[sSampleDmaReuseQueueHead2++] = (u8) i;
            }
        }
    }

    D_803B6E60 = 0;
}

#ifdef MIPS_TO_C
// dma_sample_data 3000 score diff
void *func_800BAD0C(uintptr_t devAddr, u32 size, s32 arg2, u8 *dmaIndexRef) {
    s32 hasDma = FALSE;
    struct SharedDma *dma;
    uintptr_t dmaDevAddr;
    u32 transfer;
    u32 i;
    u32 dmaIndex;
    ssize_t bufferPos;
    UNUSED u32 pad;

    if (arg2 != 0 || *dmaIndexRef >= sSampleDmaListSize1) {
        for (i = sSampleDmaListSize1; i < gSampleDmaNumListItems; i++) {
            dma = &sSampleDmas[i];
            bufferPos = devAddr - dma->source;
            if (0 <= bufferPos && (size_t) bufferPos <= dma->bufSize - size) {
                // We already have a DMA request for this memory range.
                if (dma->ttl == 0 && sSampleDmaReuseQueueTail2 != sSampleDmaReuseQueueHead2) {
                    // Move the DMA out of the reuse queue, by swapping it with the
                    // tail, and then incrementing the tail.
                    if (dma->reuseIndex != sSampleDmaReuseQueueTail2) {
                        sSampleDmaReuseQueue2[dma->reuseIndex] =
                            sSampleDmaReuseQueue2[sSampleDmaReuseQueueTail2];
                        sSampleDmas[sSampleDmaReuseQueue2[sSampleDmaReuseQueueTail2]].reuseIndex =
                            dma->reuseIndex;
                    }
                    sSampleDmaReuseQueueTail2++;
                }
                dma->ttl = 60;
                *dmaIndexRef = (u8) i;
                return &dma->buffer[(devAddr - dma->source)];
            }
        }

        if (sSampleDmaReuseQueueTail2 != sSampleDmaReuseQueueHead2 && arg2 != 0) {
            // Allocate a DMA from reuse queue 2. This queue can be empty, since
            // TTL 60 is pretty large.
            dmaIndex = sSampleDmaReuseQueue2[sSampleDmaReuseQueueTail2];
            sSampleDmaReuseQueueTail2++;
            dma = sSampleDmas + dmaIndex;
            hasDma = TRUE;
        }
    } else {
        dma = sSampleDmas;
        dma += *dmaIndexRef;
        bufferPos = devAddr - dma->source;
        if (0 <= bufferPos && (size_t) bufferPos <= dma->bufSize - size) {
            // We already have DMA for this memory range.
            if (dma->ttl == 0) {
                // Move the DMA out of the reuse queue, by swapping it with the
                // tail, and then incrementing the tail.
                if (dma->reuseIndex != sSampleDmaReuseQueueTail1) {
                    if (1) {
                    }
                    sSampleDmaReuseQueue1[dma->reuseIndex] =
                        sSampleDmaReuseQueue1[sSampleDmaReuseQueueTail1];
                    sSampleDmas[sSampleDmaReuseQueue1[sSampleDmaReuseQueueTail1]].reuseIndex =
                        dma->reuseIndex;
                }
                sSampleDmaReuseQueueTail1++;
            }
            dma->ttl = 2;
            return dma->buffer + (devAddr - dma->source);
        }
    }

    if (!hasDma) {
        // Allocate a DMA from reuse queue 1. This queue will hopefully never
        // be empty, since TTL 2 is so small.
        dmaIndex = sSampleDmaReuseQueue1[sSampleDmaReuseQueueTail1++];
        dma = sSampleDmas + dmaIndex;
        hasDma = TRUE;
    }

    transfer = dma->bufSize;
    dmaDevAddr = devAddr & ~0xF;
    dma->ttl = 2;
    dma->source = dmaDevAddr;
    dma->sizeUnused = transfer;
    osPiStartDma(&gCurrAudioFrameDmaIoMesgBufs[gCurrAudioFrameDmaCount++], OS_MESG_PRI_NORMAL,
                     OS_READ, dmaDevAddr, dma->buffer, transfer, &gCurrAudioFrameDmaQueue);
    *dmaIndexRef = dmaIndex;
    return (devAddr - dmaDevAddr) + dma->buffer;
}

//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? osPiStartDma(void *, ?, ?, s32, s32, s32, ? *); // extern
extern ? gCurrAudioFrameDmaQueue;
extern ? gCurrAudioFrameDmaIoMesgBufs;
extern ? sSampleDmas;
extern u32 gSampleDmaNumListItems;
extern u32 sSampleDmaListSize1;
extern ? sSampleDmaReuseQueue1;
extern ? sSampleDmaReuseQueue2;
extern u8 sSampleDmaReuseQueueTail1;
extern u8 sSampleDmaReuseQueueTail2;
extern u8 sSampleDmaReuseQueueHead2;
extern s32 gCurrAudioFrameDmaCount;

s32 func_800BAD0C(s32 arg0, s32 arg1, s32 arg2, u8 *arg3) {
    void *sp40;
    s32 sp30;
    s32 temp_s0;
    s32 temp_t9;
    s32 temp_v0_2;
    s32 temp_v0_4;
    s32 temp_v1_6;
    u16 temp_v0_6;
    u32 temp_a1;
    u32 temp_a1_2;
    u32 temp_v1;
    u32 temp_v1_3;
    u32 temp_v1_4;
    u8 *temp_v0_3;
    u8 *temp_v0_5;
    u8 temp_a0;
    u8 temp_a1_3;
    u8 temp_a1_4;
    u8 temp_a3;
    u8 temp_t2;
    u8 temp_t2_2;
    u8 temp_v0;
    u8 temp_v1_2;
    u8 temp_v1_5;
    void *temp_t0;
    void *temp_t0_2;
    void *phi_t0;
    u32 phi_v1;
    void *phi_a0;
    u8 phi_v1_2;
    s32 phi_t3;
    void *phi_t0_2;
    s32 phi_t2;

    phi_t3 = 0;
    phi_t3 = 0;
    if ((arg2 != 0) || (temp_a1 = sSampleDmaListSize1, temp_v0 = *arg3, phi_v1 = 0, ((temp_v0 < temp_a1) == 0))) {
        temp_a1_2 = gSampleDmaNumListItems;
        temp_v1_3 = sSampleDmaListSize1;
        phi_v1_2 = temp_v1_3;
        if (temp_v1_3 < temp_a1_2) {
            phi_a0 = (temp_v1_3 * 0x10) + &sSampleDmas;
loop_4:
            temp_v0_4 = arg0 - phi_a0->unk4;
            if ((temp_v0_4 >= 0) && ((phi_a0->unkA - arg1) >= temp_v0_4)) {
                if (phi_a0->unkE == 0) {
                    temp_a1_3 = sSampleDmaReuseQueueTail2;
                    if (sSampleDmaReuseQueueHead2 != temp_a1_3) {
                        temp_a3 = phi_a0->unkD;
                        temp_v0_5 = &sSampleDmaReuseQueue2 + temp_a1_3;
                        if (temp_a1_3 != temp_a3) {
                            *(&sSampleDmaReuseQueue2 + temp_a3) = *temp_v0_5;
                            (&sSampleDmas + (*temp_v0_5 * 0x10))->unkD = phi_a0->unkD;
                        }
                        sSampleDmaReuseQueueTail2 = temp_a1_3 + 1;
                    }
                }
                phi_a0->unkE = 0x3C;
                *arg3 = phi_v1_2;
                return (phi_a0->unk0 + arg0) - phi_a0->unk4;
            }
            temp_v1_4 = phi_v1_2 + 1;
            phi_a0 += 0x10;
            phi_v1_2 = temp_v1_4;
            if (temp_v1_4 >= temp_a1_2) {
                sp40 = phi_a0;
                goto block_14;
            }
            goto loop_4;
        }
block_14:
        temp_a1_4 = sSampleDmaReuseQueueTail2;
        phi_t0_2 = sp40;
        if ((sSampleDmaReuseQueueHead2 != temp_a1_4) && (arg2 != 0)) {
            temp_t2 = *(&sSampleDmaReuseQueue2 + temp_a1_4);
            sSampleDmaReuseQueueTail2 = temp_a1_4 + 1;
            sp30 = temp_t2;
            phi_t3 = 1;
            phi_t0_2 = &sSampleDmas + (temp_t2 * 0x10);
        }
        goto block_27;
    }
    temp_t0 = &sSampleDmas + (temp_v0 * 0x10);
    phi_t0 = temp_t0;
    phi_t0_2 = temp_t0;
    if (temp_a1 != 0) {
loop_19:
        temp_v1 = phi_v1 + 1;
        temp_v0_2 = arg0 - phi_t0->unk4;
        phi_v1 = temp_v1;
        if ((temp_v0_2 >= 0) && ((phi_t0->unkA - arg1) >= temp_v0_2)) {
            if (phi_t0->unkE == 0) {
                temp_v1_2 = sSampleDmaReuseQueueTail1;
                temp_a0 = phi_t0->unkD;
                temp_v0_3 = &sSampleDmaReuseQueue1 + temp_v1_2;
                if (temp_v1_2 != temp_a0) {
                    *(&sSampleDmaReuseQueue1 + temp_a0) = *temp_v0_3;
                    (&sSampleDmas + (*temp_v0_3 * 0x10))->unkD = phi_t0->unkD;
                }
                sSampleDmaReuseQueueTail1 = temp_v1_2 + 1;
            }
            phi_t0->unkE = 2;
            return (phi_t0->unk0 + arg0) - phi_t0->unk4;
        }
        temp_t0_2 = &sSampleDmas + (phi_v1 * 0x10);
        phi_t0 = temp_t0_2;
        phi_t0_2 = temp_t0_2;
        if (temp_v1 >= temp_a1) {
            goto block_27;
        }
        goto loop_19;
    }
block_27:
    phi_t2 = sp30;
    if (phi_t3 == 0) {
        temp_v1_5 = sSampleDmaReuseQueueTail1;
        temp_t2_2 = *(&sSampleDmaReuseQueue1 + temp_v1_5);
        sSampleDmaReuseQueueTail1 = temp_v1_5 + 1;
        phi_t0_2 = &sSampleDmas + (temp_t2_2 * 0x10);
        phi_t2 = temp_t2_2;
    }
    temp_v0_6 = phi_t0_2->unkA;
    temp_s0 = arg0 & ~0xF;
    phi_t0_2->unkE = 2;
    phi_t0_2->unk4 = temp_s0;
    phi_t0_2->unk8 = temp_v0_6;
    temp_v1_6 = gCurrAudioFrameDmaCount;
    temp_t9 = temp_v1_6 * 0x18;
    gCurrAudioFrameDmaCount = temp_v1_6 + 1;
    sp30 = phi_t2;
    sp40 = phi_t0_2;./
    osPiStartDma(temp_t9 + &gCurrAudioFrameDmaIoMesgBufs, 0, 0, temp_s0, phi_t0_2->unk0, temp_v0_6, &gCurrAudioFrameDmaQueue);
    *arg3 = phi_t2;
    return (arg0 - temp_s0) + phi_t0_2->unk0;
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/func_800BAD0C.s")
#endif

extern u32 D_803B70A8; // sDmaBufSize
extern s32 gMaxSimultaneousNotes; // gMaxSimultaneousNotes
extern struct AudioBufferParametersEU gAudioBufferParameters; // gAudioBufferParameters
//extern struct SoundAllocPool gNotesAndBuffersPool; // remove when possible. This is in heap.h
// init_sample_dma_buffers
void func_800BB030(UNUSED s32 arg0) {
    s32 i;
#define j i

    D_803B70A8 = 0x5A0;

    for (i = 0; i < gMaxSimultaneousNotes * 3 * gAudioBufferParameters.presetUnk4; i++)
    {
        sSampleDmas[gSampleDmaNumListItems].buffer = soundAlloc(&gNotesAndBuffersPool, D_803B70A8);
        if (sSampleDmas[gSampleDmaNumListItems].buffer == NULL) {
            break;
        }
        sSampleDmas[gSampleDmaNumListItems].bufSize = D_803B70A8;
        sSampleDmas[gSampleDmaNumListItems].source = 0;
        sSampleDmas[gSampleDmaNumListItems].sizeUnused = 0;
        sSampleDmas[gSampleDmaNumListItems].unused2 = 0;
        sSampleDmas[gSampleDmaNumListItems].ttl = 0;
        gSampleDmaNumListItems++;
    }

    for (i = 0; (u32) i < gSampleDmaNumListItems; i++) {
        sSampleDmaReuseQueue1[i] = (u8) i;
        sSampleDmas[i].reuseIndex = (u8) i;
    }

    for (j = gSampleDmaNumListItems; j < 0x100; j++) {
        sSampleDmaReuseQueue1[j] = 0;
    }

    sSampleDmaReuseQueueTail1 = 0;
    sSampleDmaReuseQueueHead1 = (u8) gSampleDmaNumListItems;
    sSampleDmaListSize1 = gSampleDmaNumListItems;

    D_803B70A8 = 0x180;
    for (i = 0; i < gMaxSimultaneousNotes; i++) {
        sSampleDmas[gSampleDmaNumListItems].buffer = soundAlloc(&gNotesAndBuffersPool, D_803B70A8);
        if (sSampleDmas[gSampleDmaNumListItems].buffer == NULL) {
            break;
        }
        sSampleDmas[gSampleDmaNumListItems].bufSize = D_803B70A8;
        sSampleDmas[gSampleDmaNumListItems].source = 0;
        sSampleDmas[gSampleDmaNumListItems].sizeUnused = 0;
        sSampleDmas[gSampleDmaNumListItems].unused2 = 0;
        sSampleDmas[gSampleDmaNumListItems].ttl = 0;
        gSampleDmaNumListItems++;
    }

    for (i = sSampleDmaListSize1; (u32) i < gSampleDmaNumListItems; i++) {
        sSampleDmaReuseQueue2[i - sSampleDmaListSize1] = (u8) i;
        sSampleDmas[i].reuseIndex = (u8)(i - sSampleDmaListSize1);
    }

    // This probably meant to touch the range size1..size2 as well... but it
    // doesn't matter, since these values are never read anyway.
    for (j = gSampleDmaNumListItems; j < 0x100; j++) {
        sSampleDmaReuseQueue2[j] = sSampleDmaListSize1;
    }

    sSampleDmaReuseQueueTail2 = 0;
    sSampleDmaReuseQueueHead2 = gSampleDmaNumListItems - sSampleDmaListSize1;
#undef j
}

// Similar to patch_sound, but not really
s32 func_800BB304(struct AudioBankSample *sample) {
    //struct AudioBankSample *sample = sound->sample;
    UNUSED u8 *mem;

    if (sample == (void *)NULL) {
        return -1;
    }

    if (sample->loaded == 1) {
        //temp_a1 = sound->sampleAddr // unk10;
        mem = soundAlloc(&gNotesAndBuffersPool, sample->sampleSize);
        //temp_a1_2 = temp_v0;
        if (mem == (void *)NULL) {
            return -1;
        }
        audio_dma_copy_immediate((uintptr_t)sample->sampleAddr, mem, sample->sampleSize);
        sample->loaded = 0x81;
        sample->sampleAddr = mem; // sound->unk4
    }
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800BB304(s32); // extern
void *func_800BC948(); // extern
void *func_800BC9F8(?); // extern

void func_800BB388(s32 arg1, ? arg2) {
    void *sp1C;
    void *temp_ret;
    void *temp_v0;
    void *temp_v0_2;

    if (arg1 < 0x7F) {
        temp_ret = func_800BC948();
        temp_v0 = temp_ret;
        if (temp_v0 == 0) {
            return;
        }
        if (temp_v0->unk1 != 0) {
            sp1C = temp_v0;
            func_800BB304(temp_v0->unk8);
        }
        sp1C = temp_ret;
        func_800BB304(temp_ret->unk10);
        if (temp_ret->unk2 != 0x7F) {
            func_800BB304(temp_ret->unk18);
            return;
        }
        // Duplicate return node #11. Try simplifying control flow for better match
        return;
    }
    if (arg1 == 0x7F) {
        temp_v0_2 = func_800BC9F8(arg2);
        if (temp_v0_2 == 0) {
            return;
        }
        func_800BB304(temp_v0_2->unk4);
        // Duplicate return node #11. Try simplifying control flow for better match
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/func_800BB388.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800BB43C(void *arg0, s32 arg1) {
    s16 temp_v1;
    s32 temp_v0;
    void *phi_a2;
    s32 phi_v0;
    s32 phi_v1;

    temp_v1 = arg0->unk2;
    phi_a2 = arg0;
    phi_v0 = 0;
    phi_v1 = temp_v1;
    if (temp_v1 > 0) {
        do {
            temp_v0 = phi_v0 + 1;
            phi_v0 = temp_v0;
            if (phi_a2->unk8 != 0) {
                phi_a2->unk4 = phi_a2->unk4 + arg1;
                phi_v1 = arg0->unk2;
            }
            phi_a2 += 8;
        } while (temp_v0 < phi_v1);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/func_800BB43C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 soundAlloc(? *, s32, s32); // extern
? audio_dma_copy_immediate(s32, s32, s32, s32); // extern
extern ? gNotesAndBuffersPool;

void func_800BB484(void **arg0, s32 arg1, s32 arg2) {
    void *sp2C;
    s32 sp28;
    s32 sp24;
    s32 temp_a3_2;
    s32 temp_v0_2;
    u8 temp_a0;
    void *temp_a3;
    void *temp_v0;

    temp_v0 = *arg0;
    temp_a3 = temp_v0 + arg1;
    if (temp_v0 != 0) {
        *arg0 = temp_a3;
        temp_a0 = temp_a3->unk1;
        if (temp_a0 == 0) {
            temp_a3->unk4 = temp_a3->unk4 + arg2;
            temp_a3->unk8 = temp_a3->unk8 + arg1;
            temp_a3->unkC = temp_a3->unkC + arg1;
            temp_a3->unk1 = 1;
            return;
        }
        if (temp_a0 == 0x80) {
            temp_a3_2 = temp_a3->unk4 + arg2;
            sp28 = temp_a3_2;
            sp2C = temp_a3;
            temp_v0_2 = soundAlloc(&gNotesAndBuffersPool, temp_a3->unk10, temp_a3_2);
            if (temp_v0_2 == 0) {
                temp_a3->unk4 = temp_a3_2;
                temp_a3->unk1 = 1;
            } else {
                sp24 = temp_v0_2;
                sp2C = temp_a3;
                audio_dma_copy_immediate(temp_a3_2, temp_v0_2, temp_a3->unk10, temp_a3_2);
                temp_a3->unk1 = 0x81;
                temp_a3->unk4 = temp_v0_2;
            }
            (temp_v0 + arg1)->unk8 = (temp_v0 + arg1)->unk8 + arg1;
            (temp_v0 + arg1)->unkC = (temp_v0 + arg1)->unkC + arg1;
        }
        // Duplicate return node #8. Try simplifying control flow for better match
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/func_800BB484.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800BB624(s32, s32, u8, u8); // extern
extern s32 D_803B7074;
extern s32 D_803B7080;

void func_800BB584(s32 arg0) {
    s32 sp18;
    s32 temp_v1;
    s32 temp_v1_2;
    void *temp_v0;
    void *temp_v0_2;
    void *temp_v0_3;
    s32 phi_a1;

    temp_v1 = D_803B7074;
    temp_v0 = temp_v1 + (arg0 * 8);
    if (temp_v0->unk8 == 0) {
        phi_a1 = (temp_v1 + (temp_v0->unk4 * 8))->unk4;
    } else {
        phi_a1 = temp_v0->unk4;
    }
    temp_v1_2 = arg0 * 0xC;
    temp_v0_2 = D_803B7080 + temp_v1_2;
    sp18 = temp_v1_2;
    func_800BB624(temp_v0_2->unk4 - 4, phi_a1, temp_v0_2->unk1, temp_v0_2->unk2);
    temp_v0_3 = D_803B7080 + temp_v1_2;
    temp_v0_3->unk8 = temp_v0_3->unk4->unk-4;
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/func_800BB584.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800BB484(void *, void **, ?); // extern

void func_800BB624(void **arg0, ? arg1, s32 arg2, s32 arg3) {
    s32 temp_s2;
    void **temp_s2_2;
    void **temp_v0_2;
    void *temp_s0;
    void *temp_s0_2;
    void *temp_t2;
    void *temp_v0;
    void *temp_v0_3;
    s32 phi_s4;
    s32 phi_s2;
    void **phi_s2_2;

    temp_v0 = *arg0;
    if ((temp_v0 != 0) && (arg3 != 0)) {
        *arg0 = temp_v0 + arg0;
        phi_s2 = 0;
        if (arg3 != 0) {
            phi_s4 = 0;
            do {
                temp_v0_2 = *arg0 + phi_s4;
                temp_s0 = *temp_v0_2;
                temp_s0_2 = temp_s0 + arg0;
                if (temp_s0 != 0) {
                    *temp_v0_2 = temp_s0_2;
                    if (temp_s0_2->unk2 == 0) {
                        func_800BB484(temp_s0_2 + 4, arg0, arg1);
                        temp_s0_2->unk2 = 1;
                        temp_s0_2->unkC = temp_s0_2->unkC + arg0;
                    }
                }
                temp_s2 = phi_s2 + 1;
                phi_s4 += 4;
                phi_s2 = temp_s2;
            } while (temp_s2 != arg3);
        }
    }
    phi_s2_2 = arg0 + 4;
    if (arg2 != 0) {
        do {
            temp_v0_3 = *phi_s2_2;
            temp_t2 = temp_v0_3 + arg0;
            if (temp_v0_3 != 0) {
                *phi_s2_2 = temp_t2;
                if (temp_t2->unk0 == 0) {
                    func_800BB484(temp_t2 + 8, arg0, arg1);
                    func_800BB484(temp_t2 + 0x10, arg0, arg1);
                    func_800BB484(temp_t2 + 0x18, arg0, arg1);
                    temp_t2->unk0 = 1;
                    temp_t2->unk4 = temp_t2->unk4 + arg0;
                }
            }
            temp_s2_2 = phi_s2_2 + 4;
            phi_s2_2 = temp_s2_2;
        } while (((arg2 * 4) + arg0 + 4) != temp_s2_2);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/func_800BB624.s")
#endif



#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_800B93BC(? *, ?, s32, ?, s32); // extern
? audio_dma_copy_immediate(s32, s32, s32); // extern
? func_800BB584(s32); // extern
extern ? D_803AFE18;
extern ? D_803B03C0;
extern s32 D_803B7070;
extern s32 D_803B7080;

s32 func_800BB780(s32 arg0, ? arg1) {
    s32 sp54;
    s32 sp2C;
    s32 sp28;
    s32 temp_a2;
    s32 temp_v0_2;
    u8 *temp_v0_3;
    void *temp_v0;

    temp_v0 = D_803B7070 + (arg0 * 8);
    temp_a2 = ((temp_v0->unk8 + 0x1E) & ~0xF) - 0x10;
    sp54 = temp_a2;
    sp28 = temp_v0->unk4;
    temp_v0_2 = func_800B93BC(&D_803AFE18, 1, temp_a2, arg1, arg0);
    if (temp_v0_2 == 0) {
        return 0;
    }
    sp2C = temp_v0_2;
    audio_dma_copy_immediate(sp28 + 0x10, temp_v0_2, temp_a2);
    (D_803B7080 + (arg0 * 0xC))->unk4 = sp2C + 4;
    func_800BB584(arg0);
    temp_v0_3 = arg0 + &D_803B03C0;
    if (*temp_v0_3 != 5) {
        *temp_v0_3 = 2;
    }
    return sp2C;
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/func_800BB780.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_800B93BC(? *, ?, s32, ?, s32); // extern
? func_800BAB58(void *, void *, void *, OSMesgQueue *, void *); // extern
extern ? D_803AFE18;
extern ? D_803B03C0;
extern s32 D_803B7070;
extern s32 D_803B7080;

s32 func_800BB864(s32 arg0, ? arg1, void *arg2) {
    s32 sp64;
    s32 sp3C;
    s32 sp38;
    OSMesgQueue *sp2C;
    OSMesgQueue *temp_a3;
    s32 temp_a2;
    s32 temp_v0_2;
    s32 temp_v1;
    u8 *temp_v0_3;
    void *temp_v0;

    temp_v0 = D_803B7070 + (arg0 * 8);
    temp_a2 = ((temp_v0->unk8 + 0x1E) & ~0xF) - 0x10;
    sp64 = temp_a2;
    sp38 = temp_v0->unk4;
    temp_v0_2 = func_800B93BC(&D_803AFE18, 1, temp_a2, arg1, arg0);
    sp3C = temp_v0_2;
    if (temp_v0_2 == 0) {
        return 0;
    }
    arg2->unk6 = arg0;
    temp_v1 = arg0 * 0xC;
    (D_803B7080 + temp_v1)->unk4 = temp_v0_2 + 4;
    temp_a3 = arg2 + 0x108;
    (D_803B7080 + temp_v1)->unk8 = 0;
    arg2->unk13C = temp_v0_2;
    arg2->unk144 = temp_a2;
    arg2->unk140 = sp38 + 0x10;
    sp2C = temp_a3;
    osCreateMesgQueue(temp_a3, arg2 + 0x120, 1);
    arg2->unk0 = arg2->unk0 | 8;
    func_800BAB58(arg2 + 0x140, arg2 + 0x13C, arg2 + 0x144, temp_a3, arg2 + 0x124);
    temp_v0_3 = arg0 + &D_803B03C0;
    if (*temp_v0_3 != 5) {
        *temp_v0_3 = 1;
    }
    return sp3C;
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/func_800BB864.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_800B93BC(? *, ?, s32, ?, s32); // extern
? audio_dma_copy_immediate(s32, s32, s32); // extern
extern ? D_803AFC48;
extern ? D_803B0400;
extern s32 D_803B706C;

s32 func_800BB99C(s32 arg0, ? arg1) {
    s32 sp2C;
    s32 sp28;
    s32 sp24;
    s32 temp_t9;
    s32 temp_v0;
    u8 *temp_v0_3;
    void *temp_v0_2;

    temp_v0_2 = D_803B706C + (arg0 * 8);
    temp_t9 = (temp_v0_2->unk8 + 0xF) & ~0xF;
    sp2C = temp_t9;
    sp24 = temp_v0_2->unk4;
    temp_v0 = func_800B93BC(&D_803AFC48, 1, temp_t9, arg1, arg0);
    if (temp_v0 == 0) {
        return 0;
    }
    sp28 = temp_v0;
    audio_dma_copy_immediate(sp24, temp_v0, sp2C);
    temp_v0_3 = arg0 + &D_803B0400;
    if (*temp_v0_3 != 5) {
        *temp_v0_3 = 2;
    }
    return temp_v0;
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/func_800BB99C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_800B93BC(? *, ?, s32, ?, s32); // extern
? audio_dma_copy_immediate(s32, s32, s32); // extern
? func_800BAAF8(s32, s32, s32, OSMesgQueue *, void *); // extern
extern ? D_803AFC48;
extern ? D_803B0400;
extern s32 D_803B706C;

s32 func_800BBA50(s32 arg0, ? arg1, u8 *arg2) {
    s32 sp3C;
    OSMesgQueue *sp34;
    OSMesgQueue *temp_a3;
    s32 temp_a2;
    s32 temp_s0;
    s32 temp_v0;
    u8 *temp_v0_3;
    u8 *temp_v0_4;
    void *temp_v0_2;

    temp_v0_2 = D_803B706C + (arg0 * 8);
    temp_a2 = (temp_v0_2->unk8 + 0xF) & ~0xF;
    temp_s0 = temp_a2;
    sp3C = temp_v0_2->unk4;
    temp_v0 = func_800B93BC(&D_803AFC48, 1, temp_a2, arg1, arg0);
    if (temp_v0 == 0) {
        return 0;
    }
    if (temp_s0 < 0x41) {
        audio_dma_copy_immediate(sp3C, temp_v0, temp_s0);
        temp_v0_3 = arg0 + &D_803B0400;
        if (*temp_v0_3 != 5) {
            *temp_v0_3 = 2;
        }
    } else {
        audio_dma_copy_immediate(sp3C, temp_v0, 0x40);
        temp_a3 = arg2 + 0xD4;
        sp34 = temp_a3;
        osCreateMesgQueue(temp_a3, arg2 + 0xEC, 1);
        *arg2 = *arg2 | 0x10;
        func_800BAAF8(sp3C + 0x40, temp_v0 + 0x40, temp_s0 - 0x40, temp_a3, arg2 + 0xF0);
        temp_v0_4 = arg0 + &D_803B0400;
        if (*temp_v0_4 != 5) {
            *temp_v0_4 = 1;
        }
    }
    return temp_v0;
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/func_800BBA50.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_800B9A90(s32, ?, u8); // extern
extern ? D_803B03C0;
extern s32 D_803B7078;

s32 func_800BBBA0(s32 arg0, s32 *arg1, s32 *arg2) {
    s32 temp_v0;
    u16 temp_s1;
    u8 temp_s0;
    u8 temp_s2;
    u8 temp_t0;
    s32 phi_s1;
    s32 phi_v1;
    u8 phi_s2;
    s32 phi_s7;
    s32 phi_s7_2;

    *arg2 = 0;
    *arg1 = 0;
    temp_v0 = D_803B7078;
    temp_s1 = *(temp_v0 + (arg0 * 2));
    temp_s2 = *(temp_s1 + temp_v0);
    phi_s1 = (temp_s1 + 1) & 0xFFFF;
    phi_s2 = temp_s2;
    phi_s7 = 0;
    phi_s7_2 = 0;
    if (temp_s2 != 0) {
        do {
            temp_s0 = *(phi_s1 + D_803B7078);
            phi_s1 = (phi_s1 + 1) & 0xFFFF;
            phi_v1 = 0;
            if (((*(&D_803B03C0 + temp_s0) < 2) ^ 1) == 1) {
                phi_v1 = func_800B9A90(1, 2, temp_s0);
            }
            if (phi_v1 == 0) {
                *arg2 = *arg2 + 1;
                phi_s7_2 = temp_s0 & 0xFF;
            } else {
                *arg1 = *arg1 + 1;
            }
            temp_t0 = (phi_s2 - 1) & 0xFF;
            phi_s2 = temp_t0;
            phi_s7 = phi_s7_2;
        } while (temp_t0 != 0);
    }
    return phi_s7;
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/func_800BBBA0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_800B9A90(s32, ?, u8); // extern
s32 func_800BB780(u8, ?); // extern
extern ? D_803B03C0;
extern s32 D_803B7078;

s32 func_800BBCD0(s32 arg0, s8 *arg1) {
    s32 sp34;
    s32 sp30;
    s32 temp_v0;
    u16 temp_s1;
    u8 temp_s0;
    u8 temp_s2;
    u8 temp_t6;
    s32 phi_s1;
    s32 phi_v1;
    u8 phi_s2;
    s32 phi_v1_2;

    temp_v0 = D_803B7078;
    temp_s1 = *(temp_v0 + (arg0 * 2));
    temp_s2 = *(temp_s1 + temp_v0);
    phi_s1 = (temp_s1 + 1) & 0xFFFF;
    phi_s2 = temp_s2;
    if (temp_s2 != 0) {
        do {
            temp_s0 = *(phi_s1 + D_803B7078);
            phi_s1 = (phi_s1 + 1) & 0xFFFF;
            phi_v1 = 0;
            if (((*(&D_803B03C0 + temp_s0) < 2) ^ 1) == 1) {
                phi_v1 = func_800B9A90(1, 2, temp_s0);
            }
            phi_v1_2 = phi_v1;
            if (phi_v1 == 0) {
                phi_v1_2 = func_800BB780(temp_s0, 2);
            }
            temp_t6 = (phi_s2 - 1) & 0xFF;
            phi_s2 = temp_t6;
        } while (temp_t6 != 0);
        sp34 = phi_v1_2;
        sp30 = temp_s0;
    }
    *arg1 = sp30;
    return sp34;
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/func_800BBCD0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_800B9A90(?, ?, u32); // extern
s32 func_800BB99C(u32, ?, u32); // extern
? func_800BBCD0(u32, ? *, u32); // extern
extern s32 D_800EA5DC;
extern ? D_803B03C0;
extern s32 D_803B706C;
extern u16 D_803B707C;

void func_800BBDDC(u32 arg0, s32 arg1) {
    ? sp23;
    s32 sp1C;
    s32 temp_t6;
    void *temp_v0;
    u32 phi_a2;
    u32 phi_a2_2;
    s32 phi_v1;
    u32 phi_a2_3;

    temp_t6 = arg1 & 0xFF;
    phi_a2 = arg0;
    if (arg0 < D_803B707C) {
        temp_v0 = D_803B706C + (arg0 * 8);
        if (temp_v0->unk8 == 0) {
            phi_a2 = temp_v0->unk4;
        }
        D_800EA5DC = 0x19710515;
        phi_a2_2 = phi_a2;
        if ((temp_t6 & 2) != 0) {
            sp1C = temp_t6;
            arg0 = phi_a2;
            func_800BBCD0(phi_a2, &sp23, phi_a2);
            phi_a2_2 = arg0;
        }
        phi_a2_3 = phi_a2_2;
        if ((arg1 & 0xFF & 1) != 0) {
            phi_v1 = 0;
            if (((*(&D_803B03C0 + phi_a2_2) < 2) ^ 1) == 1) {
                arg0 = phi_a2_2;
                phi_v1 = func_800B9A90(0, 2, phi_a2_2);
                phi_a2_3 = arg0;
            }
            if ((phi_v1 == 0) && (func_800BB99C(phi_a2_3, 2, phi_a2_3) == 0)) {
                D_800EA5DC = 0x76557364;
                return;
            }
            goto block_11;
        }
block_11:
        D_800EA5DC = 0x76557364;
        // Duplicate return node #12. Try simplifying control flow for better match
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/func_800BBDDC.s")
#endif
extern volatile s32 D_800EA5DC;
//load_sequence_internal
void func_800BBF44(u32 player, u32 seqId, s32 loadAsync);
//load_sequence
void func_800BBEF0(u32 player, u32 seqId, s32 loadAsync) {
    if (!loadAsync) {
        D_800EA5DC = AUDIO_LOCK_LOADING; // gAudioLoadLock
    }
    func_800BBF44(player, seqId, loadAsync);
    if (!loadAsync) {
        D_800EA5DC = AUDIO_LOCK_NOT_LOADING;
    }
}
//GLOBAL_ASM("asm/non_matchings/audio/load/func_800BBEF0.s")

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_800B9A90(?, ?, s8); // extern
s32 func_800BB864(s32, ?, void *); // extern
s32 func_800BB99C(s8, ?); // extern
s32 func_800BBA50(s8, ?, void *); // extern
s32 func_800BBBA0(s8, s32 *, s32 *); // extern
s32 func_800BBCD0(s8, void *, s32 *); // extern
? func_800BEF2C(void *); // extern
? func_800C11B0(s32); // extern
extern ? D_803B1510;
extern s32 D_803B706C;
extern u16 D_803B707C;

void func_800BBF44(s32 arg0, u32 arg1, s32 arg2) {
    s32 sp3C;
    s32 sp2C;
    s32 sp28;
    s32 sp24;
    s32 *temp_a1;
    s32 *temp_a2;
    s32 temp_a0;
    s32 temp_v0_2;
    s32 temp_v0_3;
    void *temp_s0;
    void *temp_v0;
    s8 phi_s1;
    s32 phi_v0;
    s32 phi_v1;

    phi_s1 = arg1;
    if (arg1 < D_803B707C) {
        temp_v0 = D_803B706C + (arg1 * 8);
        if (temp_v0->unk8 == 0) {
            phi_s1 = temp_v0->unk4;
        }
        temp_s0 = (arg0 * 0x148) + &D_803B1510;
        func_800BEF2C(temp_s0);
        temp_a1 = &sp28;
        temp_a2 = &sp2C;
        if (arg2 != 0) {
            sp2C = 0;
            sp28 = 0;
            temp_v0_2 = func_800BBBA0(phi_s1, temp_a1, temp_a2);
            temp_a0 = temp_v0_2;
            if (sp2C == 1) {
                sp24 = temp_v0_2;
                if (func_800BB864(temp_a0, 2, temp_s0) != 0) {
                    temp_s0->unk5 = sp24;
                    goto block_10;
                }
                // Duplicate return node #17. Try simplifying control flow for better match
                return;
            }
            if (func_800BBCD0(phi_s1, temp_s0 + 5) == 0) {
                return;
            }
            goto block_10;
        }
        if (func_800BBCD0(phi_s1, temp_s0 + 5, temp_a2) != 0) {
block_10:
            temp_s0->unk4 = phi_s1;
            temp_v0_3 = func_800B9A90(0, 2, phi_s1);
            phi_v1 = temp_v0_3;
            if (temp_v0_3 == 0) {
                if ((temp_s0->unk0 * 8) >= 0) {
                    if (arg2 != 0) {
                        phi_v0 = func_800BBA50(phi_s1, 2, temp_s0);
                    } else {
                        phi_v0 = func_800BB99C(phi_s1, 2);
                    }
                    phi_v1 = phi_v0;
                    if (phi_v0 != 0) {
                        goto block_16;
                    }
                }
            } else {
block_16:
                sp3C = phi_v1;
                func_800C11B0(arg0);
                temp_s0->unk88 = 0;
                temp_s0->unkE = 0;
                temp_s0->unk0 = temp_s0->unk0 | 0x80;
                temp_s0->unk14 = phi_v1;
                temp_s0->unk70 = phi_v1;
            }
        }
        // Duplicate return node #17. Try simplifying control flow for better match
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/func_800BBF44.s")
#endif

// L800BC170 is in a delay slot
// m2c may be inaccurate.
#ifdef MIPS_TO_C
void audio_init(void) {
    s32 sp8C;
    s32 sp60;
    s32 **sp3C;
    ? *var_v0;
    ? *var_v0_2;
    ? *var_v0_3;
    s16 temp_s3;
    s16 temp_t1;
    s32 **var_a2;
    s32 *temp_v0_2;
    s32 *temp_v0_3;
    s32 *temp_v0_4;
    s32 *temp_v0_5;
    s32 temp_a1;
    s32 temp_a1_2;
    s32 temp_a1_3;
    s32 temp_s0;
    s32 temp_s0_2;
    s32 temp_t7;
    s32 temp_v0;
    s32 var_s0_2;
    s32 var_s1;
    s32 var_v1;
    s32 var_v1_2;
    u32 var_s0;
    void *temp_t3;
    void *temp_t7_2;

    D_800EA5DC = 0;
    temp_t7 = (s32) D_800EA5D0 / 8;
    if (temp_t7 > 0) {
        var_v0 = &D_803B71B0;
        do {
            var_v0 += 8;
            var_v0->unk-4 = 0;
            var_v0->unk-8 = 0;
        } while ((u32) var_v0 < (u32) ((temp_t7 * 8) + &D_803B71B0));
    }
    var_v0_2 = &gGfxSPTaskOutputBufferSize;
    var_s0 = (u32) (&D_803B71A0 - &gGfxSPTaskOutputBufferSize) >> 3;
    if ((s32) var_s0 >= 0) {
        do {
            var_s0 -= 1;
            var_v0_2->unk4 = 0;
            var_v0_2->unk0 = 0;
            var_v0_2 += 8;
        } while ((s32) var_s0 >= 0);
    }
    temp_v0 = osTvType;
    switch (temp_v0) {                              /* irregular */
    case 0:
        D_803B7178 = D_800F2EA0;
        D_803B717C = 0x32;
        break;
    case 2:
        D_803B7178 = D_800F2EA4;
        D_803B717C = 0x3C;
        break;
    default:
    case 1:
        D_803B7178 = D_800F2EA8;
        D_803B717C = 0x3C;
        break;
    }
    func_800CBF48(&gGfxSPTaskOutputBufferSize);
    var_v0_3 = &D_803B718C;
    do {
        var_v0_3 += 2;
        var_v0_3->unk-2 = 0xA0;
    } while ((u32) var_v0_3 < (u32) &D_803B7192);
    D_803B70B8 = 0;
    D_803B70C0 = 0;
    D_803B70C4 = 0;
    D_803B70B6 = 0;
    D_803B70D4 = 0;
    D_803B70D8.unk34 = 0;
    D_803B70D8.unk84 = 0;
    osCreateMesgQueue(&D_803B6720, &D_803B6738, 1);
    osCreateMesgQueue(&gCurrAudioFrameDmaQueue, &gCurrAudioFrameDmaMesgBufs, 0x40);
    gCurrAudioFrameDmaCount = 0;
    gSampleDmaNumListItems = 0;
    func_800B90F0(D_800EA5D4);
    var_a2 = &D_803B7180;
    do {
        sp3C = var_a2;
        var_v1 = 0;
        *var_a2 = soundAlloc(&D_803AFBD8, 0xA00, var_a2);
loop_16:
        *(*var_a2 + var_v1) = 0;
        (*var_a2 + var_v1)->unk2 = 0;
        (*var_a2 + var_v1)->unk4 = 0;
        temp_t7_2 = *var_a2 + var_v1;
        var_v1 += 8;
        temp_t7_2->unk6 = 0;
        if (var_v1 != 0xA00) {
            goto loop_16;
        }
        var_a2 += 4;
    } while ((u32) var_a2 < (u32) &D_803B718C);
    D_803B0501 = 0;
    D_803B0500 = 1;
    func_800BA00C();
    D_803B706C = &sp60;
    audio_dma_copy_immediate(&_sequencesSegmentRomStart, &sp60, 0x10);
    temp_t1 = D_803B706C->unk2;
    temp_a1 = (((temp_t1 & 0xFFFF) * 8) + 0x13) & ~0xF;
    D_803B707C = temp_t1;
    temp_v0_2 = soundAlloc(&D_803AFBD8, temp_a1);
    D_803B706C = temp_v0_2;
    audio_dma_copy_immediate(&_sequencesSegmentRomStart, temp_v0_2, temp_a1);
    func_800BB43C(D_803B706C, &_sequencesSegmentRomStart);
    D_803B7070 = &sp60;
    audio_dma_copy_immediate(&_audio_banksSegmentRomStart, &sp60, 0x10);
    temp_s3 = D_803B7070->unk2;
    temp_a1_2 = ((temp_s3 * 8) + 0x13) & ~0xF;
    temp_s0 = temp_a1_2;
    temp_v0_3 = soundAlloc(&D_803AFBD8, temp_a1_2);
    D_803B7070 = temp_v0_3;
    audio_dma_copy_immediate(&_audio_banksSegmentRomStart, temp_v0_3, temp_s0);
    func_800BB43C(D_803B7070, &_audio_banksSegmentRomStart);
    D_803B7080 = soundAlloc(&D_803AFBD8, temp_s3 * 0xC);
    var_v1_2 = 0;
    if (temp_s3 > 0) {
        var_s1 = 0;
        var_s0_2 = 0;
        do {
            sp8C = var_v1_2;
            audio_dma_copy_immediate((D_803B7070 + var_s1)->unk4, &sp60, 0x10, &D_803B7080);
            (D_803B7080 + var_s0_2)->unk1 = (s8) sp60;
            var_v1_2 = sp8C + 1;
            temp_t3 = D_803B7080 + var_s0_2;
            var_s0_2 += 0xC;
            var_s1 += 8;
            temp_t3->unk2 = (s8) sp64;
        } while (var_v1_2 != temp_s3);
    }
    D_803B7074 = &sp60;
    audio_dma_copy_immediate(&_audio_tablesSegmentRomStart, &sp60, 0x10, &D_803B7080);
    temp_a1_3 = ((D_803B7074->unk2 * 8) + 0x13) & ~0xF;
    temp_s0_2 = temp_a1_3;
    temp_v0_4 = soundAlloc(&D_803AFBD8, temp_a1_3);
    D_803B7074 = temp_v0_4;
    audio_dma_copy_immediate(&_audio_tablesSegmentRomStart, temp_v0_4, temp_s0_2);
    func_800BB43C(D_803B7074, &_audio_tablesSegmentRomStart);
    temp_v0_5 = soundAlloc(&D_803AFBD8, 0x100);
    D_803B7078 = temp_v0_5;
    audio_dma_copy_immediate(&_instrument_setsSegmentRomStart, temp_v0_5, 0x100);
    func_800B907C(&D_803B01B8, soundAlloc(&D_803AFBD8, D_800EA5D8), D_800EA5D8);
    func_800C125C();
    D_800EA5DC = 0x76557364;
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/audio_init.s")
#endif
